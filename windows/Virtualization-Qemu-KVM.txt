QEMU
QEMU is a userland type 2 hypervisor for performing hardware virtualization (not to be confused with hardware-assisted virtualization), such as disk, network, VGA, PCI, USB, serial/parallel ports, etc. It is flexible in that it can emulate CPUs via dynamic binary translation (DBT) allowing code written for a given processor to be executed on another (i.e ARM on x86, or PPC on ARM). Though QEMU can run on its own and emulate all of the virtual machine’s resources, as all the emulation is performed in software it is extremely slow.

KVM
KVM is a Linux kernel module. It is a type 1 hypervisor that is a full virtualization solution for Linux on x86 hardware containing virtualization extensions (Intel VT or AMD-V). But what is full virtualization, you may ask? When a CPU is emulated (vCPU) by the hypervisor, the hypervisor has to translate the instructions meant for the vCPU to the physical CPU. As you can imagine this has a massive performance impact. To overcome this, modern processors support virtualization extensions, such as Intel VT-x and AMD-V. These technologies provide the ability for a slice of the physical CPU to be directly mapped to the vCPU. Therefore the instructions meant for the vCPU can be directly executed on the physical CPU slice.

Summary
QEMU can run independently, but due to the emulation being performed entirely in software it is extremely slow. To overcome this, QEMU allows you to use KVM as an accelerator so that the physical CPU virtualization extensions can be used. So to conclude: QEMU is a type 2 hypervisor that runs within user space and performs virtual hardware emulation, whereas KVM is a type 1 hypervisor that runs in kernel space, that allows a user space program access to the hardware virtualization features of various processors

Short overview of Image-Files formats
raw - is the default format. Allows flexible converting. Takes only used side on host, but only if used ext4 and (ext3?). This is called spare file or spare image
qed - is enhanced disc format for faster access (since QEMU 0.14). It supports overlay and sparse images. Overlay means that on create you can assign allready existing image as base and only differences will be written to the overlay image (Beware: base image has to stay unchanged!). Its also faster than qcow2
qcow2 - is most featured format in QEMU and is meant to replace qcow. This format support sparse images independent of underlying fs capabilities. It supports multiple VM-snapshots, encryption (AES) and compression.
qcowis - an old QEMU format. Images in qcow are sparse and like qcow2 independent of underlying file system capabilities.
vmdk - is standard format for VMware Workstation. Overlay function is similar to qcow2.
vdi - is standard format for Virtual Box.
parallels - is a standard image tp of virtualization solutions of Paralles Inc.
vpc - standard image format for Microsoft Virtual PC


[[Step 1]]: Check Virtualization Support in Ubuntu

Before installing KVM on Ubuntu, we are first going to verify if the hardware supports KVM. A minimum requirement for installing KVM is the availability of CPU virtualization extensions such as AMD-V and Intel-VT.

To check whether the Ubuntu system supports virtualization, run the following command. An outcome greater than 0 implies that virtualization is supported.
$ egrep -c '(vmx|svm)' /proc/cpuinfo

To check if your system supports KVM virtualization execute the command:
$ sudo kvm-ok

If the “kvm-ok” utility is not present on your server, install it by running the apt command:
$ sudo apt install cpu-checker

[[Step 2]]: Install KVM on Ubuntu 20.04 LTS

With the confirmation that our system can support KVM virtualization, we are going to install KVM, To install KVM, virt-manager, bridge-utils and other dependencies, run the command:
$ sudo apt install -y qemu qemu-kvm libvirt-daemon libvirt-clients bridge-utils virt-manager virt-viewer virtinst

A little explanation of the above packages.
- qemu package (quick emulator) is an application that allows you to perform hardware virtualization.
- qemu-kvm package is the main KVM package.
- libvritd-daemon is the virtualization daemon.
- libvirt-client is a package tht provides the virsh utility used for interacting with virtual machines.
- bridge-utils package helps you create a bridge connection to allow other users to access a virtual machine other than the host system.
- virt-manager is an application for managing virtual machines through a graphical user interface.
- virt-viewer is a utility that displays the graphical view for the virtual machine.
- virt-install is a utility that helps you to create virtual machines and install OS on those virtual machines from command line.
- virtinst is a set of command-line utilities for provisioning and modifying virtual machines.

Before proceeding further, we need to confirm that the virtualization daemon – libvritd-daemon – is running. To do so, execute the command.
$ sudo systemctl status libvirtd

You can enable it to start on boot by running:
$ sudo systemctl enable --now libvirtd

[[Step 3]]: Authorize Users to run Virtual Machines

Only members of the libvirt and kvm user groups can run virtual machines. Add a user to the libvirt & kvm group by typing:
$ sudo usermod -aG libvirt ${USER}
$ sudo usermod -aG kvm ${USER}

And grant the qemu the right to access the image folder by query the defult setting 1st.
$ sudo getfacl -e /home/<folder>
$ sudo setfacl -m u:libvirt-qemu:rx /home/<folder>

Reload updated group membership info as follows. Upon asked for a password, enter your login password.
$ exec su -l $USER

[[Step 4]]: Verify the Installation

To check if the KVM modules are loaded, run the command:
$ lsmod | grep -i kvm

Confirm the installation was successful by using the virsh command:
$ sudo virsh list --all
$ sudo virsh net-list --all
$ sudo virsh net-info default
$ sudo virsh dominfo <vm>
$ sudo virsh domifaddr <vm>
$ sudo virsh domiflist <vm>

To start or power on the virtual machine, run:
$ sudo virsh start <vm>

To shut down a virtual machine use the syntax:
$ sudo virsh shutdown <vm>

To reboot the machine, run the command:
$ sudo virsh reboot <vm>

To destroy or forcefully power off virtual machine, run:
$ sudo virsh destroy <vm>

To delete the virtual machine along with its associated storage file, run:
$ sudo virsh undefine --domain <vm> --remove-all-storage

To edit a vm xml file, use:
$ export EDITOR=vim
$ sudo virsh edit <vm>

To connect to the guest console, use the command:
$ sudo virsh console <vm> --force

To create a new virtual machine with virsh, use:
$ sudo virt-install \
  --name centos7 \
  --description "Test VM with CentOS 7" \
  --ram=1024 \
  --vcpus=2 \
  --os-type=Linux \
  --os-variant=rhel7 \
  --disk path=/var/lib/libvirt/images/centos7.qcow2,bus=virtio,size=10 \
  --graphics none \
  --location $HOME/iso/CentOS-7-x86_64-Everything-1611.iso \
  --network bridge:virbr0 \
  --console pty,target_type=serial -x 'console=ttyS0,115200n8 serial'

Sample to import existing disk image:
$ virt-install --osinfo list
$ sudo virt-install --import --name=<vm-name> \
--os-type=Linux \
--os-variant=ubuntu22.04 \
--vcpu=2 \
--ram=2048 \
--disk path=/home/<QCow2 format of KVM image>.img,size=10 \
--graphics none \
--location= \
--network bridge:virbr0

[[Step 5]]: Create Linux Bridge using brctl
If you don’t have networkmanager installed, you can use brctl command installed with the installation of bridge-utils to configure Linux bridge that we’ll use to configure KVM networking.

Create a new bridge:
$ sudo brctl addbr <virbr0>
$ sudo brctl stp <virbr0> on

Set the bridge device up:
$ sudo ip link set up dev <virbr0>

Add a device to a bridge, for example vnet0:
$ sudo brctl addif <virbr0> <vnet0>

Assigning an IP address:
$ sudo ip addr add dev <virbr0> 192.168.120.1/24 broadcast 192.168.120.255
$ sudo ip route add 192.168.120.0/24 via 192.168.120.1 dev <virbr0>

Show current bridges and what interfaces they are connected to:
$ brctl show
$ brctl showmacs <virbr0>
$ brctl showstp <virbr0>

Delete a bridge, you need to first set it to down:
$ sudo ip link set dev <virbr0> down
$ sudo brctl delbr <virbr0>

[[Step 6]]: Create Linux Bridge using XML
This network configuration uses a Linux bridge in combination with Network Address Translation (NAT) to enable a guest OS to get outbound connectivity regardless of the type of networking (wired, wireless, dial-up, and so on) used in the KVM host without requiring any specific administrator configuration.

The quickest way to get started is by utilizing existing default network configuration. Dump default network xml configuration using below command.
$ sudo virsh net-dumpxml default > mynet.xml

Edit this file accordingly and use it to define new network interface
$ sudo vim mynet.xml

<network>
  <name>mynet</name>
  <forward mode='nat'>
    <nat>
      <port start='1024' end='65535'/>
    </nat>
  </forward>
  <bridge name='virbr0' stp='on' delay='0'/>
  <ip address='192.168.120.1' netmask='255.255.255.0'>
    <dhcp>
      <range start='192.168.120.100' end='192.168.120.200'/>
    </dhcp>
  </ip>
</network>

To define a network from an XML file without starting it, use:
$ sudo virsh net-define mynet.xml

To start a (previously defined) inactive network, use:
$ sudo virsh net-start <mynet>

To create transient network that cannot be set to autostart use:
$ sudo virsh net-create mynet.xml

To set the network to autostart, use:
$ sudo virsh net-autostart <mynet>

Check to Confirm if autostart flag is turned to yes – Persistent should read yes as well.
$ sudo virsh net-list --all

To convert a network name to network UUID – previously defined UUID, use:
$ sudo virsh net-uuid <mynet>

Confirm that the bridge was successfully created, use brctl command provided by bridge-utils package to check available bridges,
$ sudo brctl show <virbr0>

Checking Ip address assigned to the interface, use ip command for this:
$ ip addr show dev <virbr0>

Attaching an interface to a VM, this takes effect immediately, and the NIC will be persistent on further reboots.
$ sudo virsh attach-interface --domain <vm> --type network --source <mynet> --model virtio --config --live/current
$ sudo virsh domiflist <vm>

Detaching an interface attached to a VM
$ sudo virsh detach-interface --domain <vm> --type network --mac <11:22:33:44:55:66> --config --live/current
$ sudo virsh domiflist <vm>

To fully remove a network, First destroy the network to put it in inactive mode:
$ sudo virsh net-destroy <mynet>

Next, undefine the network.
$ sudo virsh net-undefine <mynet>

Confirm that the network is not listed as inactive/active.
$ sudo virsh net-list --all

You can as well use brctl command to check:
$ sudo brctl show <mynet>
